DESCRIPTION DÉTAILLÉE DE L'ARCHITECTURE DE DONNÉES (au 26/07/2024)

Ce document est la référence technique de l'application "CYBER CLUB". Il décrit avec précision le mécanisme par lequel l'application importe, interprète, filtre et affiche le contenu, qui est entièrement piloté par des Google Sheets.

======================================================================
PARTIE 1 : VISION D'ENSEMBLE ET PRINCIPES FONDATEURS
======================================================================

---
### Vision d'ensemble (résumé)
---
CYBER CLUB est une plateforme web dynamique et modulable dont la caractéristique centrale est que **l'intégralité de sa structure, de son contenu et de son apparence est pilotée par des Google Sheets**. Le code agit comme un "moteur" qui interprète et affiche les données, permettant des mises à jour en temps réel sans intervention sur le code.

---
### Principes Clés
---
1.  **Source de Vérité Unique** : Les Google Sheets sont le cerveau de l'application. Toute modification de contenu, de structure (ajout/suppression de pages) ou de style (couleurs des marques) se fait dans les Sheets.
2.  **Zéro Donnée en Dur** : Le code ne contient aucune donnée métier (noms de catégories, URLs de feuilles, couleurs). Il est conçu pour être agnostique au contenu.
3.  **Architecture Modulaire** : La logique est séparée en modules clairs : récupération des données (`sheets.ts`), parsing (`sheets-parser.ts`), filtrage (`activity-filter.ts`), et utilitaires (google-drive-utils.ts).

======================================================================
PARTIE 2 : LE FLUX DE DONNÉES, DE GOOGLE SHEETS À L'ÉCRAN
======================================================================

Le processus se déroule en 4 grandes étapes :
1.  Récupération de la structure (Catégories & Marques)
2.  Navigation de l'utilisateur
3.  Récupération, Filtrage et Traitement des données de la page
4.  Affichage des données dans les composants

---
### Étape 1 : Récupération de la Structure (au chargement du site)
---
Le `RootLayout` (`src/app/layout.tsx`) initialise la structure du site en appelant deux fonctions clés de `src/lib/sheets.ts` :

1.  **`getCategories()`** :
    *   **Source** : Le **Master Sheet**.
    *   **URL** : `.../pub?gid=177392102&...&output=csv`
    *   **Rôle** : Récupère la liste des pages principales du site (Home, Projects, Catalog...). Chaque ligne du Master Sheet devient un lien dans le menu de navigation principal du `Header`.

2.  **`getBrands()`** :
    *   **Source** : Le **Brand Sheet**.
    *   **URL** : `.../pub?gid=1634708260&...&output=csv`
    *   **Rôle** : Récupère la liste des "marques" (Cyber Club, Artefact, ArchNTech...). Ces données alimentent le `Brand Selector` dans le `Header`. Chaque marque est associée à des couleurs de thème et à une `Activity` pour le filtrage.

**Mise en Cache** : Les résultats de ces deux fonctions sont mis en cache pendant 5 minutes (`unstable_cache`) pour optimiser les performances et limiter les appels à l'API Google.

---
### Étape 2 : Navigation de l'Utilisateur (dans `Header.tsx`)
---
Le `Header` utilise les données récupérées à l'étape 1 pour construire l'interface de navigation :

1.  **Menu de Navigation** : Il boucle sur le tableau `categories` pour générer les liens. Le `href` de chaque lien est construit dynamiquement pour inclure la marque actuellement sélectionnée.
    *   *Exemple (marque "Artefact" sélectionnée)* : Le lien "Projects" pointera vers `/design/projects`.
    *   *Exemple (marque "Cyber Club" ou aucune)* : Le lien "Projects" pointera vers `/projects`.

2.  **Brand Selector** : Il boucle sur le tableau `brands` pour créer les options du menu déroulant.
    *   **Action** : Lorsqu'une marque est sélectionnée, le `Header` met à jour l'URL (en utilisant `next/navigation`), ce qui déclenche un re-rendu de la page avec les bons paramètres. Le thème visuel (variable CSS `--brand-color`) est également mis à jour instantanément.

---
### Étape 3 : Traitement des Données (dans `[...slug]/page.tsx`)
---
C'est le cœur du moteur de l'application. Lorsqu'une URL est chargée (ex: `/design/projects`), la page dynamique `src/app/[...slug]/page.tsx` s'exécute :

1.  **Analyse de l'URL** : La page décode l'URL pour identifier la **catégorie** demandée ("projects") et la **marque** potentielle ("design").

2.  **Récupération des Données Brutes (`getCategoryData`)** :
    *   La page identifie la catégorie "projects" dans la liste des catégories globales.
    *   Elle extrait l'URL de la feuille de calcul correspondante (ex: `.../pub?gid=0&...`).
    *   Elle appelle `getCategoryData` qui, via `fetchAndParseCsv`, télécharge et parse le CSV de cette feuille spécifique.
    *   **Parsing Robuste (`robustCsvParse`)** : C'est une étape critique. Le parser lit le fichier CSV caractère par caractère. Il gère intelligemment les guillemets (`"`) pour s'assurer que les virgules et les sauts de ligne à l'intérieur des descriptions ou des champs de texte ne cassent pas le parsing. Il transforme le texte CSV brut en un tableau d'objets JavaScript fiables.

3.  **Filtrage par Activité (`filterItemsByBrandActivity`)** :
    *   **Source** : `src/lib/activity-filter.ts`.
    *   **Logique** : Le tableau d'objets fraîchement parsé est immédiatement passé à la fonction `filterItemsByBrandActivity`.
        *   Si la marque est "Cyber Club", la fonction retourne tous les items sans filtrage.
        *   Sinon, elle récupère l'activité associée à la marque (ex: "Artefact" → "Design").
        *   **Gestion Multi-Activités** : La fonction vérifie si la colonne `Activity` de chaque item (ex: "Design, Architecture") **contient** l'activité cible. Pour cela, elle utilise `parseItemActivities` pour séparer la chaîne "Design, Architecture" en un tableau `["Design", "Architecture"]` et vérifie si l'activité cible est présente.

4.  **Traitement des Données Filtrées (`processGalleryLinks`)** :
    *   **Source** : `src/lib/sheets.ts` et `src/lib/google-drive-utils.ts`.
    *   **Logique** : Chaque item du tableau *filtré* est ensuite passé à `processGalleryLinks`. Cette fonction nettoie et structure les données :
        *   Elle transforme les liens Google Drive (ex: `.../file/d/ID/view`) en liens de thumbnail directs (ex: `https://drive.google.com/thumbnail?id=ID`).
        *   Elle gère les champs contenant plusieurs liens (séparés par un saut de ligne `\n`) en les transformant en un tableau d'URLs propres (ex: `galleryUrls`).

---
### Étape 4 : Affichage Final (dans `[...slug]/page.tsx`)
---
À ce stade, la page dispose d'un tableau de données `finalData`, où chaque objet est propre, structuré et prêt à être affiché.

1.  **Grille d'Items** : La page boucle sur `finalData`. Pour chaque item, elle rend une `<Card>`.

2.  **Rendu Conditionnel et Robuste** :
    *   **Titre** : Utilise une chaîne de fallback pour toujours avoir un titre : `item.Title || item.Name || item.Item || 'Untitled'`.
    *   **Image Principale** : Affiche l'image en utilisant une logique de priorité : `item.coverUrl` d'abord, sinon `item.galleryUrls[0]`, sinon `item['Url Logo Png']`. Si aucune image n'est trouvée, la section de l'image n'est pas rendue.
    *   **Badges d'Activité** : La chaîne `item.Activity` est passée à `parseItemActivities` pour la transformer en tableau. Le code boucle ensuite sur ce tableau pour afficher **une pastille `<Badge>` distincte pour chaque activité**.
    *   **Autres Champs** : Tous les autres champs (description, liens PDF/STL, auteur, date) sont affichés de manière conditionnelle (`{item.description && ...}`), ce qui empêche toute erreur si un champ est manquant dans le Google Sheet.

**En résumé :** Le système est conçu pour être résilient et flexible. Il lit la structure depuis le Master Sheet, récupère les données brutes de la feuille correspondante, les filtre intelligemment, les nettoie, puis les affiche de manière sécurisée, en s'adaptant à la présence ou à l'absence de n'importe quelle colonne. La complexité est gérée en amont, rendant l'affichage final simple et fiable.
